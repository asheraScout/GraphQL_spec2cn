# GraphQL

工作草案 - 2016年10月

## 介绍

这是GraphQL的RFC规范草案，它是由Facebook在2012年创建的用于描述客户端 - 服务器应用程序的数据模型的功能和要求的查询语言。该标准的开发始于2015年。GraphQL目前并不完整，还是一门崭新的不断发展的语言，在本规范的未来版本中将持续改进。

__版权声明__

版权所有（c）2015-2017，Facebook，Inc.保留所有权利。

允许使用源代码和二进制形式进行重新分发和使用，只要符合以下条件，即可使用或不进行修改：

- 源代码的再分发必须保留上述版权声明，此条件列表和以下免责声明。
- 二进制形式的再分发必须在发行版提供的文档和/或其他资料中复制上述版权声明，条件列表和以下免责声明。
- Facebook的名称或其贡献者的名称均不得用于在未经事先书面许可的情况下支持或宣传本软件产生的产品。

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

## 目录

[TOC]

## 1. 概述

GraphQL是一种查询语言，利用它提供的直观灵活的语法和用来描述数据需求及交互的系统，我们可以更好的构建客户端应用程序。

例如，这个GraphQL请求从Facebook的GraphQL接口实现中获取id为4的用户名。

```
{
  user(id: 4) {
    name
  }
}
```
返回如下数据（JSON格式）

```
{
  "user": {
    "name": "Mark Zuckerberg"
  }
}
```
GraphQL不是一种能够进行任意计算的编程语言，他是被设计用来查询根据本规范定义功能接口的应用程序服务器。GraphQL不会强制要求实现它的应用程序服务器使用特定的编程语言或存储系统。应用程序服务器只需实现功能，并将其映射到一整套统一的语言，类型系统和GraphQL的设计哲学。GraphQL为工具构建提供了强大的平台，对产品开发来说，它提供了一套友好统一的接口。
GraphQL有一些设计原则：

- 层次化：今天，大多数产品开发涉及创建和操纵视图层次结构。为了实现应用程序结构的一致性，GraphQL查询本身是分层结构的。查询的格式就像它返回的数据一样。客户端描述数据需求的方式非常自然。
- 以产品为中心：GraphQL完全由需求视图和编写它们的前端工程师驱动。GraphQL从他们的思维方式和需求开始，建立起这套语言和实现其必备的运行时环境。
- 强类型：每个GraphQL服务器都定义了特定于应用程序的类型系统。所有查询在该类型系统的上下文环境中执行。在查询执行之前，工具会确保查询语法正确，在GraphQL类型系统检查中也是合法的。服务器会保证响应的格式和内容正常。
- 客户端指定查询：通过其类型系统，GraphQL服务器会告知客户端可以使用的功能。客户端负责指定如何调用这些已发布的功能。查询粒度细化到字段。以往，在没有GraphQL的大多数客户端-服务器应用程序中，是服务器来决定其对各种脚本化终端返回数据的格式。而GraphQL查询能够做到不多不少的返回客户端要求的内容。
- 内省：GraphQL是内省的。如本规范中所述，GraphQL服务器的类型系统必须可以由GraphQL语言本身查询。GraphQL内省功能使它成为构建通用工具和客户端软件库的强大平台。

得益于以上这些原则，GraphQL是一个构建客户端应用程序的强大而高效的环境。产品开发人员和设计者通过这些高质量工具支持的GraphQL服务器，无需阅读大量文档即可快速提高生产力，这中间甚至不需要正式的培训。而为了实现这一切，首先必须建立这些服务器和工具。
以下正式规范作为开发者的参考。规范描述了语言及其语法，类型系统和用于查询自身的内省系统，以及以算法为后盾的执行校验引擎。规范的目标是为尚在构建的GraphQL工具，客户端库和服务器端实现的整个生态（跨架构和平台）提供一个基础和框架。为了做到这一点，我们期待与社区合作。

## 2. 语言
客户端使用GraphQL查询语言向GraphQL服务发出请求。我们将这些请求源称为文档。文档可能包含操作（查询，突变和订阅）以及一种允许查询复用的通用组合单元的片段。
GraphQL文档被定义为句法（syntactic grammar），其中终止符号是标记（不可分割的词汇单位）。这些标记在词法（lexical grammar）中定义，它与源字符（由双冒号::定义）的模式相匹配。

### 2.1 源文本

```
源字符::
    /[\u0009\u000A\u000D\u0020-\uFFFF]/
```
GraphQL文档表示为Unicode字符序列。但为了尽可能广泛地与现有工具，语言和序列化格式兼容，并且避免文本编辑器和源码控制工具的显示问题，除了极少数例外，大部分GraphQL仅以ASCII原生非控制字符表示。

#### 2.1.1 Unicode

```
Unicode字节序标记::
    字节序标记 (U+FEFF)
```
非ASCII的Unicode字符可以随意出现在GraphQL的字符值和注释部分。
“字节顺序标记（BOM, Byte Order Mark）”是一个可能出现在包含Unicode的文件的开头的特殊的Unicode字符，被程序用来确定文本流是Unicode，文本流的字节序，以及选用何种Unicode编码来解析。

#### 2.1.2 空白

```
空白::
    水平制表符 (U+0009)
    空格 (U+0020)
```
空白用于提高源文本的可读性，作为标记之间的间隔，在任何标记的前后都可能会出现任意数量的空白。标记之间的空白对于GraphQL查询文档的语义并不重要，但是字符串或注释标记出现的空白字符是不可忽略的。

__注意__ GraphQL有意不将Unicode“Zs”类别字符视为白白，避免了文本编辑器和源码控制工具的误解。

#### 2.1.3 行终止符

```
行终止符::
    新行 (U+000A)
    回车 (U+000D)[lookahead != 新行 (U+000A)]
    回车 (U+000D) 新行 (U+000A)
```
像空白一样，行终止符用于提高源文本的可读性，任何其他标记的前后都有可能出现任意数量的行终止，它与GraphQL查询文档的语义无关。任何其他标记都不包含行终止符。

__注意__ 任何给出语法错误来源行号的错误报告都应该使用前面的行终止符数量来生成行号。

#### 2.1.4 注释

```
注释::
    # 注释字符(列表)(可选)
注释字符::
    除了行终止符的源字符
```
GraphQL源文档可以包含单行注释，以＃打头。
注释可以包含除行终止符以外的任何Unicode码点，因此注释始终以＃字符开始，由不包括行终止符的其他任意码点构成。
注释的行为和空白很像，可能出现在任何标记之后，也可能出现在行终止符之前，并且对GraphQL查询文档的语义没有任何意义。

#### 2.1.5 无意义的逗号

```
逗号::
    ,
```
与空白和行终止符类似，逗号（,）用于提高源文本和单独的词法标记的可读性，但在GraphQL查询文档中语法和语义上都不重要。
这个无意义的逗号字符确保了无论是否存在都不会改变文档的语法解释，这可能是其他语言用户常会犯的一个错误。后置逗号或行终止符也可以作为列表分隔符使用，这些分隔符通常对源码的可读性和可维护性有帮助。

#### 2.1.6 词汇标记

```
标记::
    标点
    名称
    整数值
    浮点值
    字符串值
```
GraphQL文档由源Unicode字符模式在词法中定义的几种不可分割的词汇标记组成。
标记后面会被用作GraphQL查询文档句法中的终止符号。

#### 2.1.7 忽略标记

```
会被忽略的::
    Unicode字节顺序标记
    空白
    行终止符
    注释
    逗号
```
每个词汇标记的前后都可能是任意数量的被忽略的标记，包括空格和注释。源文档中其他不被忽略的区域是有意义的，但这些忽略的源字符可能会以有意义的方式出现在词法标记中，例如字符串中可能包含空白字符。
解析某些标记时不会忽略任何字符，例如在定义浮点数的字符之间不允许有空格字符。

#### 2.1.8 标点符号

```
标点:: 以下之一
    !	$	(	)	...	:	=	@	[	]	{	|	}
```
GraphQL文档包括标点符号以便描述结构。GraphQL是一种数据描述语言，而不是编程语言，因此GraphQL缺少那些通常用于描述数学表达式的标点符号。

#### 2.1.9 名称

```
名称::
    /[_A-Za-z][_0-9A-Za-z]*/
```
GraphQL查询文档充满了命名的东西：操作，字段，参数，指令，片段和变量。所有的名称必须遵循相同的语法形式。
GraphQL中的名称区分大小写。也就是说name，Name和NAME都是指不同的名称。下划线也很重要，other_name和othername是两个不同的名称。
GraphQL中的名称仅限于以上这些可选字符的ASCII子集，以便配合支持尽可能多的其他系统。

### 2.2 查询文档

```
文档:
    定义（列表）
定义:
    操作定义
    片段定义
```
GraphQL查询文档可以描述由GraphQL服务接收到的完整文件或请求字符串。文档包含多个操作和片段的定义。GraphQL查询文档如果包含操作则只能由服务器执行。但是不包含操作的文档仍然可以被解析和验证，这样，客户端就能够跨文档表示单个请求。
如果一个文档只包含一个操作，该操作可以省略查询关键字和操作名称，不命名或以简写形式表示。如果GraphQL查询文档包含多个操作，则每个操作都必须命名。当向GraphQL服务提交具有多个操作的查询文档时，还必须提供要被执行的对应操作的名称。

### 2.3 操作

```
操作定义:
    操作类型 名字（可选） 变量定义（可选） 指令（可选） 选集
    选集
操作类型: 以下之一
    查询	突变	订阅
```
GraphQL模型有三种操作类型：

- 查询 - 只读读取。
- 突变 - 写入，然后读取。
- 订阅 - 保持活跃的获取源事件响应中数据的请求。

每个操作由可选的操作名称和选集表示。
例如，这个突变操作首先“点赞”了一个故事，然后检索点赞的数量：

```
mutation {
  likeStory(storyID: 12345) {
    story {
      likeCount
    }
  }
}
```
__查询简写__
如果一个文档只包含一个查询操作，并且该查询没有定义变量，也不包含任何指令，那么该操作可以省略查询关键字和查询名称简单表示。
例如，这个未命名的查询操作是通过查询简写来表示的。

```
{
  field
}
```
__注意__ 后面有很多例子会使用到查询短语法。

### 2.4 选集

```
选集:
    {选项（列表）}
选项:
    字段
    片段拓展
    内联片段
```
操作可以选择它需要的一组信息，并且将准确的获取到这些信息，不多不少。

```
{
  id
  firstName
  lastName
}
```
在上面这个查询中，`id`，`firstName`和`lastName`三个字段组成了一个选集。选集也可以包含片段引用。

### 2.5 字段

```
字段:
    别名（可选） 命名 参数（可选） 指令（可选） 选集（可选）
```
选集主要由字段组成。一个字段描述了可在选集中请求的一个独立的信息。
一些字段描述复杂数据或与其他数据的关系。为了进一步得到这些数据，字段本身可以包含一个选集，进行深入嵌套的请求。所有GraphQL操作必须将其选择粒度精确到可以返回标量的字段，以确保明确的响应格式。
例如，这个操作的选集中复杂数据和关系的字段精确到了标量。

```
{
  me {
    id
    firstName
    lastName
    birthday {
      month
      day
    }
    friends {
      name
    }
  }
}
```
操作的顶层选集中的字段通常表示你的应用程序及其当前用户可全局访问的一些信息。 这样的典型示例包括对当前登录用户的引用，或访问由唯一标识符引用的某些类型的数据。

```
# `me` 表示当前登录用户.
{
  me {
    name
  }
}

# `user` 表示众多绑定唯一标识符的用户中的一个
{
  user(id: 4) {
    name
  }
}
```

### 2.6 参数

```
参数表:
    (参数（列表）)
参数:
    命名: 值
```
字段可以在概念上理解为是一种函数，某些情况下接受改变其行为的参数。这些参数通常直接映射到GraphQL服务器实现中的函数参数。
在这个例子中，我们要查询特定用户（通过id参数请求）及其特定尺寸的个人资料图片：

```
{
  user(id: 4) {
    id
    name
    profilePic(size: 100)
  }
}
```
给定字段可能存在多个参数：

```
{
  user(id: 4) {
    id
    name
    profilePic(width: 100, height: 50)
  }
}
```
__参数无序__
参数可以以任何句法顺序提供，并保持相同的语义。
这两个查询在语义上是相同的：

```
{
  picture(width: 200, height: 100)
}
{
  picture(height: 100, width: 200)
}
```

### 2.7 字段别名

```
别名:
    名称:
```
默认情况下，响应对象中的键值将使用查询的字段名。但是你也可以通过指定别名来定义不同的名称。
在这个例子中，我们可以获取两个不同大小的个人资料图片，并确保生成的对象不会有重复的键：

```
{
  user(id: 4) {
    id
    name
    smallPic: profilePic(size: 64)
    bigPic: profilePic(size: 1024)
  }
}
```
响应：

```
{
  "user": {
    "id": 4,
    "name": "Mark Zuckerberg",
    "smallPic": "https://cdn.site.io/pic-4-64.jpg",
    "bigPic": "https://cdn.site.io/pic-4-1024.jpg"
  }
}
```
由于查询的顶层是一个字段，它也可以给出一个别名：

```
{
  zuck: user(id: 4) {
    id
    name
  }
}
```
响应：

```
{
  "zuck": {
    "id": 4,
    "name": "Mark Zuckerberg"
  }
}
```

### 2.8 片段

```
片段拓展:
    ... 片段名 指令（可选）
片段定义:
    片段 片段名 类型条件 指令（可选） 选集
片段名:
    名称 但不能是“on”
```
片段是GraphQL中组合的主要单位。
片段允许在选择中复用重复字段，减少文档中的重复文本。内联片段可以在选择中直接使用，以便在针对界面或联合查询时对类型条件进行调整。
例如，如果我们想获取一些关于共同的朋友以及一些用户的朋友的常见信息：

```
query noFragments {
  user(id: 4) {
    friends(first: 10) {
      id
      name
      profilePic(size: 50)
    }
    mutualFriends(first: 10) {
      id
      name
      profilePic(size: 50)
    }
  }
}
```
可以将重复的字段提取成片段放入父片段或查询中。

```
query withFragments {
  user(id: 4) {
    friends(first: 10) {
      ...friendFields
    }
    mutualFriends(first: 10) {
      ...friendFields
    }
  }
}

fragment friendFields on User {
  id
  name
  profilePic(size: 50)
}
```
使用扩展运算符（...）插入片段。片段所选的所有字段将被添加到与片段调用相同级别的查询字段选择中。多层片段拓展也是一样。
例如：

```
query withNestedFragments {
  user(id: 4) {
    friends(first: 10) {
      ...friendFields
    }
    mutualFriends(first: 10) {
      ...friendFields
    }
  }
}

fragment friendFields on User {
  id
  name
  ...standardProfilePic
}

fragment standardProfilePic on User {
  profilePic(size: 50)
}
```
查询`noFragments`，`withFragments`和`withNestedFragments`都会获得相同格式的响应。

#### 2.8.1 类型条件

```
类型条件:
    on 命名的类型
```
片段必须指定其适用的类型。在上面的例子中，friendFields可以用在查询User的上下文中。
不能在任何输入值（标量，枚举或输入对象）上指定片段。
可以在对象类型，接口和联合上指定片段。
片段中的选择只有当其正在运行的对象的具体类型与片段的类型匹配时才返回值。
例如在Facebook数据模型的这个查询中：

```
query FragmentTyping {
  profiles(handles: ["zuck", "cocacola"]) {
    handle
    ...userFragment
    ...pageFragment
  }
}

fragment userFragment on User {
  friends {
    count
  }
}

fragment pageFragment on Page {
  likers {
    count
  }
}
```
`profiles`根字段返回列表，其中每个元素可以是`Page`或`User`。当profiles的对象结果是一个`User`，`friends`将会出现，`likers`不会。而当结果是`Page`时，`likers`将会出现， `friends`不会。

```
{
  "profiles": [
    {
      "handle": "zuck",
      "friends": { "count" : 1234 }
    },
    {
      "handle": "cocacola",
      "likers": { "count" : 90234512 }
    }
  ]
}
```

#### 2.8.2 内联片段

```
内联片段:
    ...类型条件（可选） 指令（可选） 选集
```
片段可以在选集内部内联定义，这样，片段就能基于其运行时类型包含相应的字段。在`query FragmentTyping`示例中演示了标准片段包含，我们也可以使用内联片段来完成同样的事情。

```
query inlineFragmentTyping {
  profiles(handles: ["zuck", "cocacola"]) {
    handle
    ... on User {
      friends {
        count
      }
    }
    ... on Page {
      likers {
        count
      }
    }
  }
}
```

也可以使用内联片段将指令应用于一组字段。如果省略了类型条件，则内联片段被认为与封闭上下文的类型相同。

```
query inlineFragmentNoType($expandedInfo: Boolean) {
  user(handle: "zuck") {
    id
    name
    ... @include(if: $expandedInfo) {
      firstName
      lastName
      birthday
    }
  }
}
```
### 2.9 输入值

```
值[Const]:
    [~Const]变量
    整数值
    浮点值
    字符串值
    布尔值
    空值
    枚举值
    列表值[?Const]
    对象值[?Const]
```
字段和指令参数接受多种字面原语输入，输入值可以是标量，枚举值，列表或输入对象。
如果未定义为常量（例如，在默认值中 ），可以将输入值指定为变量。列表和输入对象也可以包含变量（除非定义为常量）。

#### 2.9.1 整数值

```
整数值::
    整数部分
整数部分::
    负号（可选） 0
    负号（可选） 非零数字 数字（列表，可选）
负号::
    -
数字:: 以下之一
    0	1	2	3	4	5	6	7	8	9
非零数字::
    数字里非0的
```
整数不带小数点或指数（例如 1）。

#### 2.9.2 浮点值

```
浮点值::
    整数部分 小数部分
    整数部分 指数部分
    整数部分 小数部分 指数部分
小数部分::
    .数字（列表）
指数部分::
    指数指示符 符号（可选） 数字（列表）
指数指示符
    e	E
符号
    +	-
```
浮点数包括小数点或指数或两者都有。

#### 2.9.3 布尔值

```
布尔值: 以下之一
    true	false
```
两个关键字true和false表示两个布尔值

#### 2.9.4 字符串值

```
字符串值::
    ""
    "字符（列表）"
字符::
    源字符 但不能是 " 或 \ or 行终止符
    \u 转义Unicode
    \ 转义字符
转义Unicode::
    /[0-9A-Fa-f]{4}/
转义字符:: 以下之一
    "	\	/	b	f	n	r	t
```
字符串是用双引号（ " ）（例如"Hello World" ）包裹的字符序列。空格和其他被忽略的字符在字符串值中很重要。
__注意__ Unicode字符允许在字符串值文字中，但是GraphQL源文本不能包含这些ASCII控制字符，因此必须使用转义序列来表示这些字符。
__语义__
字符串值::""

1. 返回一个空的字符序列.

字符串值:: "字符（列表）"

1. 返回一个包含所有这些字符的Unicode字符序列.

字符::源字符 但不能是 " 或 \ or 行终止符

1. 返回源字符的字符值

字符:: \u 转义Unicode

1. 返回字符，它是Unicode基本多语言平面的16位十六进制值对应的转义Unicode字符。

字符:: \ 转义字符

1. 返回转义字符的字符值，具体如下：

| 转义字符 | 码值 | 字符名 |
| --- | --- | --- |
| " | U+0022 | 双引号 |
| \ | U+005C | 反斜杠 |
| / | U+002F | 斜杠 |
| b | U+0008 | 退格 |
| f | U+000C | 换页 |
| n | U+000A | 换行 |
| r | U+000D | 回车 |
| t | U+0009 | 水平制表符 |

#### 2.9.5 空值

```
NullValue:
    null
```
空值表示为关键字null。
GraphQL有两种语义上不同的方式来表示缺少值：
- 明确地提供字面值：null。
- 根本不提供值。
举个例子，下面两个字段调用相似，但不完全相同：

```
{
  field(arg: null)
  field
}
```
第一个已经明确地为参数“arg”提供了null ，而第二个隐含地没有为参数“arg”提供一个值。这两种形式在一些情况下可能会有所不同。 例如，分别表示删除字段和不改变字段的突变，这两种形式都不能输入非空类型。
__注意__ 通过变量表示缺少值有两种方法，一种是提供一个空值变量， 另一种是根本不提供变量。

#### 2.9.6 枚举值

```
枚举值:
    名称 但不能是true或false或null
```
枚举值表示为无引号的名称（例如`MOBILE_WEB`）。建议枚举值“全部大写”。枚举值仅用于已知精确枚举类型的上下文中。因此，没有必要在文字中提供枚举类型名称。

#### 2.9.7 列表值

```
列表值[Const]:
    []
    [值[?Const](列表)]
```
列表是用方括号[ ]包裹的有序序列。 列表内的值可以是任何值文字或变量（例如[1, 2, 3]）。
逗号在GraphQL中是可选的，因此逗号可以放在最后，重复的逗号不代表缺少值。
__语义__
ListValue: []

1. 返回一个新的空列表。

ListValue: [值（列表）]

1. 首先让输入列表成为一个新的空列表值。
2. 然后对每一个值（列表）
    a. 对值求值
    b. 把求值后的结果附加到输入列表中去
3. 返回输入列表

#### 2.9.8 输入对象值

```
对象值[Const]:
    {}
    {对象字段[?Const](列表)}
对象字段[Const]:
    名称: 值[?Const]
```
输入对象字面值是包裹在大括号{ }中的带键值的无序列表。对象字面值可以是任何文字或变量（例如`{name: "Hello world", score: 1.0 }`）。我们将输入对象的字面表达式称为“对象字面值”。
__输入对象字段无序__
输入对象字段可以以任何句法顺序提供，并保持相同的语义。
这两个查询在语义上是相同的：

```
{
  nearestThing(location: { lon: 12.43, lat: -53.211 })
}
{
  nearestThing(location: { lat: -53.211, lon: 12.43 })
}
```
__语义__
对象值: {}

1. 返回没有字段的新的输入对象

对象值: {对象字段(列表)}

1. 让输入对象成为一个新的空对象
2. 对ObjectField内的每个字段
    a. 使输入对象成为一个没有字段的新的输入对象
    b. 对对象字段内的每个字段求值出结果
    c. 添加求值后的键值到输入对象上
3. 返回输入对象

### 2.10 变量

```
变量:
    $ 名称
多个变量定义:
    (变量定义(列表))
变量定义:
    变量 : 类型 默认值(可选)
默认值:
    = 值[Const]
```
可以使用变量对GraphQL查询进行参数化，最大化查询复用，并避免运行时在客户端中繁琐的构建查询字符串。
如果没有定义为常量（例如，在默认值中 ），则可以为输入值提供一个变量。
变量必须在操作的顶部定义，并且作用域是整个执行过程。
在这个例子中，我们想要根据特定设备的大小获取个人资料图片大小：

```
query getZuckProfile($devicePicSize: Int) {
  user(id: 4) {
    id
    name
    profilePic(size: $devicePicSize)
  }
}
```
这些变量的值与请求一起提供给GraphQL服务，因此可以在执行期间替换它们。如果为变量值提供JSON，我们可以运行此查询并请求大小为60的个人资料图片：

```
{
  "devicePicSize": 60
}
```
__片段内的变量使用__
查询变量可以在片段中使用，作用域是给定操作的全局范围，因此在片段中使用的变量必须在插入片段的顶层操作中声明。如果一个变量在一个片段中被引用，包含这个片段的操作却没有定义这个变量，则操作不能执行。

### 2.11 输入类型

```
类型:
    命名类型
    列表类型
    非空类型
命名类型:
    命名
列表类型:
    [ 类型 ]
非空类型:
    命名类型 !
    列表类型 !
```
GraphQL描述了查询变量所期望的数据类型。输入类型可以是其他输入类型的列表，也可以是任何其他输入类型的非空变体。
__语义__
类型: 名称

1. 得到名称的字符串值
2. 使类型等于模式（Schema）定义中对应名称的类型
3. 类型不能为空
4. 返回类型

类型: [ 类型 ]

1. 使表项类型等于类型求值后的值
2. 使类型等于包含表项类型的列表类型.
3. 返回类型

类型: 类型 !

1. 使可空类型等于类型求值后的值
2. 使类型等于包含可空类型的非空类型.
3. 返回类型

### 2.12 指令

```
多个指令: 
    指令(列表)
指令:
    @ 名称 参数(可选)
```
指令提供了一种在GraphQL文档中描述备选的运行时执行和类型校验行为的方法。
在某些情况下，我们需要提供选项来改变在字段参数不足时GraphQL的执行行为，例如有条件地包含或跳过一个字段。指令通过向执行者描述额外的信息来做到这一点。
指令有一个名称，以及一个可以接受任何输入类型的参数列表。
指令可用于描述类型，字段，片段和操作的额外信息。
GraphQL的未来版本如果采用了新的可配置执行功能，它们可能通过指令发布。

## 3 类型系统

GraphQL类型系统描述GraphQL服务器的功能，用于确定查询是否有效。类型系统还描述了查询变量的输入类型，以确定运行时提供的值是否有效。
GraphQL服务器的功能被称为该服务器的“模式”。模式根据其支持的类型和指令进行定义。
一个给定的GraphQL模式必须自洽。本节介绍相关验证过程的规则。
GraphQL模式由每种操作的根类型表示：查询，突变和订阅; 这决定了类型系统中这些操作开始的位置。
GraphQL模式中的所有类型都必须具有唯一的名称。任意两个类型的名称都不可能相同。没有类型可以与内置类型（包括标量和内省类型）的名称冲突。
GraphQL模式中的所有指令必须具有唯一的名称。指令和类型可以共享相同的名称，因为它们之间没有歧义。
在模式中定义的所有类型和指令的名称都不能以“__”（两个下划线）开头，因为它仅由GraphQL的内省系统使用。

### 3.1 类型

任何GraphQL模式的基本单位都是类型。GraphQL中有8种类型。
最基本的类型是标量。一个标量表示一个原语值，如字符串或整数。通常，标量字段的可能响应是可枚举的。 在这些情况下，GraphQL提供了一个枚举类型，可以指定有效响应的空间。
标量和枚举在响应树中形成叶结点; 中间层是对象类型，它们定义一组字段，其中每个字段是系统中的另一种类型，允许定义任意类型层次结构。
GraphQL支持两种抽象类型：接口和联合。
接口定义一个字段列表; 实现该接口的对象类型保证实现这些字段。只要类型系统声明它将返回一个接口，它将返回一个有效的实现类型。
联合定义一个可能的类型列表; 类似于接口，当类型系统声明一个联合将被返回时，将返回一个可能的类型。
到目前为止，所有类型都假定是可空的和单数的：例如标量字符串返回空或单数字符串。类型系统可能希望定义它返回其他类型的列表; 为此，提供了列表类型，并包装了另一种类型。类似地，非空类型包装另一种类型，并表示结果将永远不为空。这两种类型称为“包装类型”; 非包装类型称为“基本类型”。包装类型具有底层“基本类型”，通过不断地展开该类型直到找到基本类型。
最后，通常提供复杂的结构作为GraphQL查询的输入是有用的; 输入对象类型允许模式在这些查询中准确地定义客户端期望的数据。

#### 3.1.1 标量

如字面，在GraphQL中，一个标量表示一个原语值。GraphQL响应采用分层树的形式;这些树上的叶节点是GraphQL标量。
所有的GraphQL标量都可以表示为字符串，不过取决于所使用的响应格式，给定的标量类型可能有更合适的原语，服务器在适当的时候应该使用这些类型。
GraphQL提供了许多内置的标量，但是类型系统也可以添加具有语义的额外标量。例如，GraphQL系统可以定义一个名为时间（Time）的标量，该标量虽然序列化为字符串，但仍承诺符合ISO-8601。当查询类型为时间的字段，你可以使用ISO-8601解析器解析结果，然后使用客户端特定于时间的原语。另外一个可能有用的定制标量的例子是Url，它作为字符串序列化，但由服务器保证是一个有效的URL。
服务器可以从其模式中省略任何内置的标量，例如，如果模式不引用浮点数，那么它不会包含Float类型。但是，如果模式包含了我们在这里描述的类型，则必须遵守相应所描述的行为。例如，服务器不能包含一个名为Int的类型，并使用它来表示128位数字或国际化信息。

__结果强制__

GraphQL服务器在提供给定标量类型的字段时，必须遵守标量类型的描述，要么限制值，要么抛出错误。
例如，GraphQL服务器可能在提供Int类型的字段的时候收到了浮点数。由于服务器不能产生非整数打破规则，服务器应该截断分数部分，仅仅返回整数部分。如果服务器收到一个布尔true值，它应该返回1。如果服务器遇到一个字符串，它可能会尝试解析为10进制整数值。如果服务器不能合理地转换成Int，那么就必须抛出一个字段错误。
结果强制对GraphQL服务器的客户端是不可见的，精确规则都留给服务器实现。唯一的要求是，服务器返回必须符合给定标量类型。

__输入强制__

如果GraphQL服务器需要一个标量类型作为输入参数，这种强制是可见的，并且规则必须被很好的定义。如果输入的值不匹配强制规则，必须抛出查询错误。
GraphQL具有不同常量字面值来表示整数和浮点输入值，并且根据收到的输入值类型的不同应用不同的强制规则。GraphQL可以通过查询变量被参数化，通过HTTP传输时通常会将这些值序列化。由于一些常见的序列化（例如：JSON）对整数和浮点值之间不进行区分，如果它们的小数部分为空（例如，1.0），它们将被解释为整数输入值，否则被解释为浮点输入值。
对于下文的所有类型，非空的例外，如果明确提供了空值，那么输入强制的结果为空。

__内置标量__

GraphQL提供了一套良好定义的基础标量集。一个GraphQL服务器应该支持所有这些类型，并且遵循以下描述的行为。

##### 3.1.1.1 整数

整形标量类型表示带符号的32位不带小数的数值。支持32位整数或者数字类型的响应格式应该使用这个类型来表示标量。

__结果强制__

如果可能的话，GraphQL服务器应该强制非整形原始值转换到整形，否则就应该抛出字段错误。这方面的例子包括浮点数1.0返回为1，或字符串"2"返回为2。

__输入强制__

当作为输入类型时，只有整数输入值可以被接受。所有其他的输入值，包括数字内容的字符串，都必须抛出指示不正确类型的查询异常。如果整数输入值表示一个比-2^31小或比2^31打的值，应该抛出查询错误。

__注意__ 大于32位的整数值应该要么用字符串表示，要么用自定义的标量类型，因为不是所有平台和协议都支持编码比32位大的整数。

##### 3.1.1.2 浮点数

浮动标量类型表示IEEE754中定义的有符号的双精度的小数值。支持适当的双精度数类型的响应格式应该使用这个类型来表示该标量。

__结果强制__

如果可能的话，GraphQL服务器应该强制非浮点原始值转换到浮点类型，否则就应该抛出字段错误。这方面的例子包括整数1返回为1.0，或字符串"2.0"返回为2.0。

__输入强制__

当作为输入类型时，整数和浮点的输入值都可以被接受。整数的输入值会被强制加上空的小数部分，例如整数输入值1会被转化成1.0。所有其他的输入值，包括数字内容的字符串，都必须抛出指示不正确类型的查询异常。如果整数输入值表示了一个不符合IEEE754的值，应该抛出查询错误。

##### 3.1.1.3 字符串

字符串标量类型表达文本数据，表示为UTF-8字符的序列。字符串类型是GraphQL中最经常使用来代表各种形式的人类可读的文本。所有的响应格式必须支持字符串表示法，并且表示法一定要在当时使用。

__结果强制__

如果可能的话，GraphQL服务器应该强制非字符串原始值转换为字符串，否则就应该抛出字段错误。这方面的例子包括布尔值true返回为字符串"true"或整数1返回为字符串"1"。

__输入强制__

当作为输入类型时，只有有效的UTF-8字符串的输入值才被接受。所有其他的输入值都必须抛出指示不正确类型的查询异常。

##### 3.1.1.3 布尔值

布尔标量类型表示true或false。如果支持，响应格式应使用内置布尔类型; 否则，应该用他们的整数的表示：1和0。

__结果强制__

如果可能的话，GraphQL服务器应该强转非布尔原始值，否则就应该抛出字段错误。这方面的例子包括对任何非零数返回true。

__输入强制__

作为输入的类型，只有布尔输入值被接受。所有其他的输入值都必须抛出指示不正确类型的查询异常。

##### 3.1.1.5 ID

ID标量类型代表一个唯一标识符，通常用于重新获取一个对象或作为缓存的键值。ID类型序列化方式和字符串相同; 然而这不是为了使它对人可读。虽然它往往是数字，它应始终序列化为一个字符串。

__结果强制__

GraphQL不知道ID的格式，它把ID序列化成字符串来确保不同格式的ID表示能够统一，小的如自增的数字，大的如128位随机数，再到base64编码值，抑或是类似GUID那样的字符串值。
GraphQL服务器应该强制给定的ID格式是服务器想要的，如果不能强转必须抛出字段异常。

__输入强制__

作为输入的类型，任何字符串（如"4"）或整数（例如4）输入值都应该被强制转换为GraphQL服务器想要的ID格式。任何其它的输入值，包括浮点输入值（如4.0）都必须抛出指示不正确类型的查询异常。

#### 3.1.2 对象

GraphQL查询分层组织描述信息树。标量类型描述这些分层查询的叶节点值，对象则描述了中间层。
GraphQL对象代表命名字段的一个列表，其中每一个字段生成一个特定类型的值。对象的值应当被序列化保证有序，其中的查询字段名（或别名）是键，相应字段求值结果是值，按它们出现在查询中的顺序排序。
Object类型中定义的所有字段的名字都不能以“__”（两个下划线）开头，因为这是GraphQL的自省系统专用的。
例如，一种类型的Person可以被描述为：

```
type Person {
  name: String
  age: Int
  picture: Url
}
```
这里name是一个字段，产生一个字符串值，然后age是一个字段，产生的整数值，最后picture是一个字段，产生Url值。
一个对象的查询必须至少选择一个字段。字段的选择将产生包含查询的对象确定子集的有序映射，顺序与查询时表达的相同。只有在对象类型中声明的字段才可以合法的出现在针对这个对象的查询里。
例如，选择Person的所有字段：

```
{
  name
  age
  picture
}
```
将会产生这样的对象：

```
{
  "name": "Mark Zuckerberg",
  "age": 30,
  "picture": "http://some.cdn/picture.jpg"
}
```
当选择字段的一个子集时：

```
{
  age
  name
}
```
只会产生下面这样确定的子集：

```
{
  "age": 30,
  "name": "Mark Zuckerberg"
}
```

对象类型的字段可以是一个标量，枚举，另一个对象类型，接口，或联合。此外，它还可以是任何类型的包装，基于的类型是下面五个之一。
例如，Person 类型包含一个关系：

```
type Person {
  name: String
  age: Int
  picture: Url
  relationship: Person
}
```

有效的查询必须对返回字段中的对象提供一个嵌套的字段集，所以这个查询是无效的：

```
{
  name
  relationship
}
```
但这个例子是有效的：

```
{
  name
  relationship {
    name
  }
}
```

对查询的每个对象都会产生一个子集：

```
{
  "name": "Mark Zuckerberg",
  "relationship": {
    "name": "Priscilla Chan"
  }
}
```

__字段顺序__

查询对象时，所得结果的字段映射和它们在查询执行的时候的顺序是相同的，但这不包括类型不适用的片段或那些被@skip及@include指令跳过的片段。这个顺序是由CollectFields()算法正确生成。
响应的序列化格式在表达序列化映射时应该保持顺序。只能表示无序图的序列化格式应当在语法上保留这个顺序（如JSON）。
响应的字段顺序和请求时相同可以提高调试时的可读性，并且假如属性的顺序可预料，响应解析可以更高效。
如果一个片段在其他字段之前，该片段指定的字段在响应中也应该出现在其他那些字段之前。

```
{
  foo
  ...Frag
  qux
}

fragment Frag on Query {
  bar
  baz
}
```
产生下列有序结果：

```
{
  "foo": 1,
  "bar": 2,
  "baz": 3,
  "qux": 4
}
```

如果某个字段在选择中被多次查询，排序时以它出现的第一次的位置为准。但不适用的片段不影响排序。

```
{
  foo
  ...Ignored
  ...Matching
  bar
}

fragment Ignored on UnknownType {
  qux
  baz
}

fragment Matching on Query {
  bar
  qux
  foo
}
```
产生如下有序结果：

```
{
  "foo": 1,
  "bar": 2,
  "qux": 3
}
```
另外，如果字段中的指令结果被排除，它们也不会在排序时被考虑。

```
{
  foo @skip(if: true)
  bar
  foo
}
```
产生如下有序结果：

```
{
  "bar": 1,
  "foo": 2
}
```

__结果强制__

决定对象强制结果的是GraphQL核心，所以这在文档的那部分讨论。

__结果强制__

对象作为输入在任何情况下都不是合法的。

##### 3.1.2.1 对象字段参数

对象字段概念上可以理解为返回值的函数。有些情况下对象字段可以接受参数来更进一步地指定返回值。对象字段参数由所有可能的参数名称组成的列表和其预期的输入类型定义。
字段定义的所有参数都不能以“__”（两个下划线）开头，因为这是GraphQL的自省系统专用的。
例如，Person类型有一个picture字段可以接受一个参数来确定返回什么尺寸的图像。

```
type Person {
  name: String
  picture(size: Int): Url
}
```

GraphQL查询可以向指定了参数的字段有选择提供这些参数。

```
{
  name
  picture(size: 600)
}
```

得到如下结果：

```
{
  "name": "Mark Zuckerberg",
  "picture": "http://some.cdn/picture_600.jpg"
}
```
对象字段参数的类型可以是任何输入类型。

##### 3.1.2.2 对象字段废弃

必要的时候，程序可以把对象中的字段标记为废弃。但查询这些字段仍然是合法的（以确保现有客户端不会因此不能正常使用），但字段应该在文档和工具中进行适当处理。





















































































































































































































































































































































































